---
title: 命令模式
date: 2023-12-13T20:14:34.000Z
tags: null
categories: null
---

把请求封装成一个对象，从而分离请求发起和执行。发起者和执行者之间通过命令对象进行沟通，便于请求对象的储存、传递、调用、增加和管理。

```c++
class Command {
  protected:
    Application* app_;
    Editor* editor_;
    std::string backup_;
  public:
    Command(Application* app, Editor* editor): app_(app), editor_(editor) {}
    void saveBackup() {
      backup_ = editor_->text;
    }
    void undo() {
      editor_->setText(backup_);
    }
    virtual bool execute() = 0;
};

class CopyCommand: public Command {
  bool execute() override {
    app_->setClipboard(editor_->getSelection());
    return true;
  }
};

class CutCommand: public Command {
  bool execute() override {
    saveBackup();
    app_->setClipboard(editor_->getSelection());
    editor_->deleteSelection();
    return true;
  }
};

class PasteCommand: public Command {
  bool execute() override {
    saveBackup();
    editor_->replaceSelection(app->getClipboard());
    return true;
  }
};

class UndoCommand: public Command {
  bool execute() override {
    app_->undo();
    return false;
  }
};

class CommandHistory {
  private:
    std::vector<Command*> history_;
  public:
    void push(Command* c) {
      history_.push_back(c);
    }
    Command* pop() {
      if (history_.empty()) return nullptr;
      Comman* cmd = history_.back();
      history_.pop_back();
      return cmd;
    } 
};

class Editor {
  public:
    std::string text_;
    std::string getSelection() {
      // get copy of selected text
    }
    void deleteSelection() {
      // delete selected text
    }
    void replaceSelection(std::string text) {
      // insert the contents at the current position
    }
};

class Application {
  public:
    std::string clipboard_;
    std::vector<Editor*> editors_;
    Editor* activeEditor_;
    CommandHistory history;

    void createUI {
      // create necessary elements

      std::function<void()> copy = [this]() {
        executeCommand(new CopyCommand(this, activeEditor_));
      }
      copyButton.setCommand(copy);
      shortcuts.onKeyPress("ctrl+c", copy);

      std::function<void()> cut = [this]() {
        executeCommand(new CutCommand(this, activeEditor_));
      }
      cutButton.setCommand(cut);
      shortcuts.onKeyPress("ctrl+x", cut);

      std::function<void()> undo = [this]() {
        executeCommand(new UndoCommand(this, activeEditor_));
      }
      undoButton.setCommand(undo);
      shortcuts.onKeyPress("ctrl+z", undo);
    }

    void executeCommand(Command* c) {
      if (c->execute()) history.push(c);
      else delete c;
    }

    void undo() {
      auto command = history.pop();
      if (command) command->undo();
    }
};
```
