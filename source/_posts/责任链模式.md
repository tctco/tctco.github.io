---
title: 责任链模式
date: 2023-12-12T20:41:04.000Z
tags: null
categories: null
---

通常而言，责任链模式涉及到一个共同的接口或抽象类，各个实际处理类继承该接口并持有下一个处理器的引用。

但是下面这个例子将给出一个在GUI设计中的特殊责任链实现模式，通过子组件对父组件的继承关系自然形成引用。下面的设计通过`Container* container`指针实现了链路，同时，向上传递的过程被抽象出来，安插在`Component`类中。

> 这种实现方式是将所有业务逻辑全部包含在类内部的思路，它更加清晰，但同时也缺乏可扩展性。

```c++
class ComponentWithContextualHelp {
  public:
    virtual void showHelp() const = 0;
    virtual ~ComponentWithContextualHelp() {}
};

class Component: public ComponentWithContextualHelp {
  protected:
    Container* container;
  public:
    std::string tooltipText;

    void showHelp() {
      if (!tooltipText.empty()) // show tooltip
      else container->showHelp();
    }
    void setContainer(Container* pContainer) {
      container = pContainer;
    }
};

class Container: public Component {
  protected:
    std::vector<Component*> components;
  public:
    void add(Component* child) {
      components.push_back(child);
      child->setContainer(this);
    }
};

class Button: public Component {
  // 
};

class Panel: public Container {
  public:
    std::string modalHelpText;
    void showHelp() {
      if (!modalHelpText.empty()) // show modal window for help
      else Container::showHelp();
    }
};

class Dialog: public Container {
  public:
    std::string wikiPageUrl;
    void showHelp() {
      if (!wikiPageUrl.empty()) // show wiki help page
      else Container::showHelp(); 
      // 或者也可以更显式地调用而非通过继承: container->showHelp()
    }
};
```
