---
title: 桥梁模式
date: 2023-12-09 21:52:46
tags:
categories:
---

将“抽象化Abstraction”与“实现化Implementation”解耦。抽象的本意是将强耦合（继承）转换为弱耦合（聚合）。这里的抽象与实现不是一般程序设计下的抽象与实现
- 抽象：主要指高层的控制层，定义了基于“实现”的操作，如“遥控器”操作“电视机”。但是遥控器只负责发射指令，不关心指令的具体实现。
- 实现：抽象行为的具体执行者，比如“电视机”接受“遥控器”发出的关机指令。电视机接收指令，并负责关闭自己。

如此一来，抽象与实现就可以解耦，分别维护。

> 个人感觉最直观的还是类多维度解耦最直观：比如设备有电视、收音机；遥控器有基本遥控器、高级遥控器。如果用vanilla OOP的角度，需要设计4个类：电视基本遥控器、电视高级遥控器……但是使用桥接模式可以把实现（机器）绑定（聚合）给抽象（遥控器）。机器、遥控器实现相同的接口即可。


```cpp
class RemoteControl {
  protected:
    Device device_;
  public:
    RemoteControl(Device& device): device_(device) {}
    void togglePower() {
      if (device_.isEnabled()) device_.disable();
      else device_.enable();
    }
    void volumeDown() {
      device_.setVolume(device_.getVolume() - 10);
    }
    void volumeUp() {
      device_.setVolume(device_.getVolume() + 10);
    }
    void channelDown() {
      device_.setChannel(device_.getChannel() - 1);
    }
    void channelUp() {
      device_.setChannel(device_.getChannel() + 1);
    }
}

class AdvancedRemoteControl: public RemoteControl {
  public:
    void mute() {
      device_.setVolume(0);
    }
}

class Device { // interface, provides only primitive operations
  private:
    bool enabled_;
    int volume_;
    int channel_;
  public:
    virtual bool isEnabled() const = 0;
    virtual void enable() = 0;
    virtual void disable() = 0;
    virtual int getVolume() const = 0;
    virtual void setVolume(int percent) = 0;
    virtual int getChannel() const = 0;
    virtual void setChannel(int channel) = 0;
}

// all devices follow the same interface
class TV: public Device {
  // ...
}

class Radio: public Device {
  // ...
}

int main(int argc, char* argv[]) {
  TV* tv = new TV();
  Remote* remote = new RemoteControl(*tv);
  remote.togglePower();

  Radio* radio = new Radio();
  AdvancedRemote* advancedRemote = new AdvancedRemoteControl(*radio);

  delete tv;
  delete remote;
  delete radio;
  delete advancedRemote;
}
```