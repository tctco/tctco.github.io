---
title: 代理模式
date: 2023-12-09T00:16:51.000Z
tags: null
categories: null
---

代理模式感觉也是套一层壳。

> 适配器模式主要关注于解决接口的不兼容性问题，而代理模式主要关注于控制对其它对象的访问

```c++
class ThirdPartyYouTubeLib {
  public:
    virtual std::vector<Video> listVideos() const = 0;
    virtual Video getVideoInfo(int videoId) const = 0;
    virtual void downloadVideo(int videoId) const = 0;
}

class ThirdPartyYouTubeClass: public ThirdPartyYouTubeLib {
  public:
    std::vector<Video> listVideos() {
      // return list of videos
    }

    Video getVideoInfo(int videoId) {
      // return VideoInfo by videoId
    }

    void downloadVideo(int videoId) {
      // download a video
    }
}

class CachedYouTubeClass: public ThirdPartyYouTubeLib {
  private:
    ThirdPartyYouTubeLib* service;
    std::vector<Video>* listCache;
    Video* videoCache;
  public:
    bool needReset;

    CachedYouTubeClass(ThirdPartyYouTubeLib* service): service(service), needReset(false), listCache(nullptr), videoCache(nullptr) {
      if (!service) {
        throw std::invalid_argument("service cannot be nullptr");
      }
    }
    ~CachedYouTubeClass() {
      delete listCache;
    }

    std::vector<Video> listVideos() {
      std::vector<Video> videos;
      if (listCache == nullptr || needReset) {
        delete listCache;
        listCache = new std::vector<Video>;
        videos = service->listVideos();
        for (int i = 0; i < videos.size(); i++)
          listCache->push_back(videos[i]);
      } else {
        for (int i = 0; i < listCache->size(); i++)
          videos.push_back(*listCache[i]);
      }
      return videos;
    }

    Video getVideoInfo(int id) {
      if (videoCache == nullptr || needReset) {
        delete videoCache;
      }
      Video newVideo = service->getVideoInfo(id)
      videoCache = new Video(newVideo);
      return *videoCache; // 存在破坏封装性的风险，考虑返回一个副本更妥当
    }

    void downloadVideo(int id) {
      if (!videoExists(id) || needReset)
        service->downloadVideo(id);
    }
}
```
